#include "rtc.h"

static uint8_t rtc_flag = 0;

// RTC Function Pointers
file_table_t rtc_file = {
    .read = read_rtc,
    .write = write_rtc,
    .open = open_rtc,
    .close = close_rtc
};

// returns -1 on failure, and 0 on success of setting the rtc frequency

/* set_freq
 * 
 * Helper function to set the frequency of the rtc interrupts
 * Inputs: freq - desired frequency for the interrupts to be set to
 * Outputs: -1 upon faiilue, 0 upon success
 * Side Effects: if freq is correct, rtc interrupt timing will be changed
 */
static int8_t set_freq(uint32_t freq){
      
    // converting input frequency to rate used by registers
    char rate;
    // conversion from frequency to rate
    switch (freq){
        case 0x2:   rate  = 0x0F;   break;
        case 0x4:   rate  = 0x0E;   break;
        case 0x8:   rate  = 0x0D;   break;
        case 0x10:  rate  = 0x0C;   break;
        case 0x20:  rate  = 0x0B;   break;
        case 0x40:  rate  = 0x0A;   break;
        case 0x80:  rate  = 0x09;   break;
        case 0x100: rate  = 0x08;   break;
        case 0x200: rate  = 0x07;   break;
        case 0x400: rate  = 0x06;   break;  // limit to frequency of 1024 for user programs 
        default :   return -1;
    }
    outb(RTC_REG_A, RTC_PORT);              // set index to register A, disable NMI
    // set frequency
    char prev = inb(RTC_PORT+1);
    outb(RTC_REG_A, RTC_PORT);
    outb((prev & SET_FREQ_BITMASK) | rate, RTC_PORT+1); // keep first four bits of RTC_PORT+1, and set second four to rate
    return 0;
}


/* rtc_init
 * 
 * Initializes RTC
 * Inputs: None
 * Outputs: None
 * Side Effects: enables RTC on the PIC, sends periodic interrupt set up code to RTC port register
 *               sets frequency of periodic interrups
 */
void rtc_init(void){
    
    // setting the registers, mask all interrupts to avoid taking too long to initialize rtc
    unsigned long flags;
    cli_and_save(flags);                    // cli and save flags
    outb(RTC_REG_B, RTC_PORT);              // select register B and disable NMI
    char prev = inb(RTC_PORT+1);            // store previous port value
    outb(RTC_REG_B, RTC_PORT);              // reading will reset index to register D
    outb(prev|BIT_6_MASK, RTC_PORT+1);            // turn on bit 6 of register B

    // set frequency
    set_freq(RTC_FREQ_DEF);
    restore_flags(flags);                   // restore interrupts

    enable_irq(IRQ_RTC);                    // enable interrupt on PIC

}


/* rtc_handler
 * 
 * Handles interrupts generated by RTC, plays test_interrupts
 * Inputs: None
 * Outputs: None
 * Side Effects: sends acknowledgement of receipt of interrupt to PIC and RTC register
 */
void rtc_handler(void){
    cli();
    // mask and acknowledge interrupt
    send_eoi(IRQ_RTC);

    // for each process: for each fd: if it's an rtc file add a tick
    int i, j;
    for (j = 0; j < PROCESSNUM; j++){
        if (globalPCB[j] && globalPCB[j]->file_desc) {
            file_t* fd = globalPCB[j]->file_desc;
            for (i = 2; i < FILENUM; i++) {
                if (fd[i].f_tbl == &rtc_file) {
                    if (fd[i].f_pos == 0) {
                        fd[i].f_pos = fd[i].inode_num;
                        fd[i].priv_data = 1;
                    }
                    fd[i].f_pos--;
                }
            }
        }
    }

    rtc_flag = 1;

    // read status register C, so that we acknolwedge we're ready to read another interrupt
    outb(RTC_REG_C_NMI, RTC_PORT);
    inb(RTC_PORT+1);

    // reenable interrupt
    enable_irq(IRQ_RTC);
    sti();
}

/* read_rtc
 * 
 * Returns when the next interrupt occures
 * Inputs: rtc - rtc file struct to store information about interrupt
 *         buf - unused for this system call
 *         nbytes - unused for this system call
 * Outputs: 0 when read is finished
 * Side Effects: None
 */
int32_t read_rtc(file_t* rtc, int8_t* buf, int32_t nbytes) {
    rtc_flag = 0;
    while (1){
        while(!rtc_flag);
        if (rtc->priv_data == 1) {rtc->priv_data = 0; return 0;}
        rtc_flag = 0;
    }
}

/* write_rtc
 * 
 * Changes the frequency of the RTC interrupts
 * Inputs: rtc - rtc file struct to store informaiton about interrupt
 *         buf - buffer that stores the frequency
 *         nbytes - should be 4, because input should be uint32_t types
 * Outputs: 4 upon success, -1 upon failure (incorrect input)
 * Side Effects: Changes the RTC interrupt rate
 */

int32_t write_rtc(file_t* rtc, int8_t* buf, int32_t nbyte) {

    // check whether the number of bytes is the size of a uint32_t type
    if (nbyte != FOURBYTE) return -1;
    if (buf){
        // check if freq is power of 2
        if ((*(int32_t*)buf != 0) && ((*(int32_t*)buf & (*(int32_t*)buf - 1)) == 0)){
            rtc->inode_num = RTC_FREQ_DEF/(*(int32_t*)buf);
            rtc->f_pos = 0;
            return 0;
        }
    }
    return -1;
}

/* open_rtc
 * 
 * Resets the RTC interrupt rate, opens the file
 * Inputs:  filename - unused here, for system call
 * Outputs: 0 upon opening
 * Side Effects:  Changes the RTC interrupt frequency to 2
 */
int32_t open_rtc(file_t* file) {
    file->inode_num = 1;
    file->f_pos = 0;
    return 0;
}

/* close_rtc
 * 
 * Closes file and resets the interrupt rate to user rate
 * Inputs: fd - unused here, for system call
 * Outputs: 0 upon closing
 * Side Effects: Changes the RTC interrupt frequency to 1024
 */
int32_t close_rtc(file_t* file){ 
    set_freq(RTC_FREQ_DEF);   
    return  0;
}
